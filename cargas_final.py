# -*- coding: utf-8 -*-
"""cargas_final.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NSwtTyHFE1vJA4qDWsmyDkmwOP9wx75r
"""

from scipy.optimize import minimize
from google.colab import files
import matplotlib.pyplot as plt
from numpy import loadtxt
import numpy as np
import math
ep = 8.8541878176e-12 
raio = 1 # raio da região interna

files.upload()

files.upload()

dataset = loadtxt('cargas2 (2).txt')
matN = dataset[:,0:2]
n = matN.shape[0] # numero de cargas

dataset = loadtxt('potencial.txt')
matM = dataset[:,0:2]
m = matM.shape[0] # numero de medidas de potencial

def calcula_raio(v1,v2):
  return np.linalg.norm( v1-v2 )

def inicializar(mat):
  for i in range(0,mat.shape[0]):
    for j in range(0,mat.shape[1]):
      mat[i,j] = 1/( 4.0*np.pi*ep*calcula_raio( matN[j],matM[i] ) ) # 'N' posição das cargas # 'M' posição dos potenciais
  return mat
#
def inicializar_x0(x0):
  k0=0
  for i in range(0,mat.shape[0]):
    for j in range(0,mat.shape[1]):
      x0[k0] = calcula_raio( matN[j],matM[i] ) 
      k0 = k0 + 1 
  return x0

def resolveq(mat,phi):
  #return np.matmul( np.linalg.pinv( np.matmul(mat.transpose(),mat) ), mat.transpose() ).dot(phi)
  #return np.matmul( np.linalg.inv( np.matmul(mat.transpose(),mat) ), mat.transpose() ).dot(phi)
  return np.linalg.lstsq(mat, phi, rcond=None)[0]

mat = np.empty((m,n))
mat_final = np.zeros((m,n))
q = np.empty((n))
q_final = np.empty((n))
phi = np.empty((m))
phi = dataset[:,2] 

x0 = np.zeros( shape=(m*n) )
x_final = np.zeros( shape=(m*n) ) 
inicializar(mat)
inicializar_x0(x0)

def obj(x):
  k=0
  for i in range(0,mat.shape[0]):
    for j in range(0,mat.shape[1]):
      mat[i,j]=1/( 4.0*np.pi*ep*x[k] )
      k=k+1
  return np.linalg.norm( np.linalg.norm(np.matmul(mat,q)-phi )/m )

b = 0
erro = 1.0
while True:
  result = minimize(obj, x0, method='Nelder-Mead', tol=1e-5)
  #result = differential_evolution(obj, bounds,strategy='best1exp', updating='immediate')
  q = resolveq(mat,phi)
  if result.fun < erro or b==0 :
    erro = result.fun
    print(b,result.fun)
    q_final = np.copy(q)
    x0 = np.copy(result.x)
  if result.fun < 1.0e-12 or b == 100 : 
    break    
  b = b + 1 
#
k=0
for i in range(0,mat_final.shape[0]):
  for j in range(0,mat_final.shape[1]):
    mat_final[i,j]=1/( 4.0*np.pi*ep*x0[k] )
    k=k+1

print(q_final)
print(" ")
print(x0)

print( np.linalg.norm(np.matmul(mat_final,q_final)-phi )/m )

x0 = x0.reshape((m, n))
print(x0)
print(" ")
x0 = x0.transpose()
print(x0)
print(" ")
print(result.x)

#print(matM)
#print(matM[0,0],matM[0,1],matM[1,0],matM[1,1],matM[2,0],matM[2,1])

for i in range(0,n):
  #print("soma",sum(x0[i,:]) )
  xteste = ( -10.0e0 , -10.0e0 )
  #
  def obj2(x):
    soma = 0
    for j in range(0,x0.shape[1]):
      soma = soma +abs( math.sqrt( ( x[0] - matM[j,0])**2 + ( x[1] - matM[j,1])**2 ) - x0[i,j] ) 
    return soma
  #
  b=0
  while True:
    result = minimize(obj2, xteste, method='Powell', tol=1e-5)
    xteste = np.copy(result.x)
    if b==100 : 
      break
    b = b + 1

  #matNf[i] = np.copy(result.x)
  print(i,result.x,result.fun)

print(q_final)

